{"version":3,"file":"feditor_helper.min.js","sources":["../src/feditor_helper.js"],"sourcesContent":["/* eslint-disable no-return-assign */\n/* eslint-disable no-unused-vars */\n// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Helper\n * @package   gradingform_frubric\n * @copyright 2021 Veronica Bermegui\n * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\ndefine([\"core/log\"], function (Log) {\n    \"use strict\";\n\n    return {\n        // Helper function to get the closest parent with a matching selector\n        getClosest: function (elem, selector) {\n            for (; elem && elem !== document; elem = elem.parentNode) {\n                if (elem.matches(selector)) {\n                    return elem;\n                }\n            }\n            return null;\n        },\n\n        getPreviousElement: function (elem, selector) {\n\n            // Get the previous sibling element\n            var sibling = elem.previousElementSibling;\n\n            // If there's no selector return.\n            if (!selector) {\n                return;\n            }\n\n            // If the sibling matches our selector, use it\n            // If not, jump to the next sibling and continue the loop\n            while (sibling) {\n\n                if (sibling.matches(selector)) {\n                    return sibling;\n                }\n                sibling = sibling.previousElementSibling;\n            }\n        },\n\n        getDistanceFromCriterionHeader: function (elem, selector) {\n            var sibling = elem.previousElementSibling;\n            var distance = -1;\n            // If there's no selector return.\n            if (!selector) {\n                return;\n            }\n\n            while (sibling) {\n                distance++;\n                if (sibling.matches(selector)) {\n                    return distance;\n                }\n                sibling = sibling.previousElementSibling;\n            }\n\n        },\n\n        getNextElement: function (elem, selector) {\n            // Get the next sibling element\n            var sibling = elem.nextElementSibling;\n            // If there's no selector, return\n            if (!selector) {\n                return;\n            }\n            // If the sibling matches our selector, use it\n            // If not, jump to the next sibling and continue the loop\n            while (sibling) {\n                if (sibling.matches(selector)) {\n                    return sibling;\n                }\n                sibling = sibling.nextElementSibling;\n            }\n        },\n        // Returns the criteria parsed to array.\n        getCriteriaJSON: function () {\n            return JSON.parse(document.getElementById(\"id_criteria\").value);\n        },\n\n        getLevelsJSON: function (criteriaid) {\n            return document.getElementById(`advancedgrading-frubric-${criteriaid}-leveljson`).value;\n        },\n\n        setCriteriaJSON: function (criterioncollection) {\n            return document.getElementById('id_criteria').value = JSON.stringify(criterioncollection);\n        },\n\n        getCriterionFromCriteriaCollection: function (row, criterioncollection) {\n\n            const filteredCriterion = criterioncollection.filter(function (criterion, index) {\n                const id = row.getAttribute('data-criterion-group');\n\n                criterion.rowindex = index;\n                if (id == criterion.id) {\n                    return criterion;\n                }\n            }, row);\n\n            return filteredCriterion;\n        },\n\n        getRandomID: function () {\n            return (Math.floor(Math.random() * 9999));\n        },\n\n        getMode: function () {\n            return document\n                .querySelector(\".criterion-header\")\n                .getAttribute(\"data-mode\");\n        },\n\n        getMinMax: function (score) {\n            if (score.indexOf('-') != -1) {\n                return score.split('-');\n            } else {\n                return score.split('/');\n            }\n        },\n\n        // The table structure is different when creating the frubric.\n        // We need a way to find the max value. getMaxValueInLevelInCriterion\n        getMaxValueInLevelInCriterion: function (groupid) {\n            const maxvalues = [];\n            const marks = document.querySelectorAll(`.level-${groupid} .level-mark .fmark`);\n\n            Array.from(marks).forEach(score => {\n                const minmax = score.value.split('-');\n                maxvalues.push(Number(minmax[minmax.length - 1]));\n\n            }, maxvalues);\n\n            return Math.max(...maxvalues);\n        },\n\n        /**\n         * Keep track of the JSON so in case it the validation fails.\n         * We send this value that has the data set to be rerended.\n         * @param {JSON} criteria\n         */\n        setHiddenCriteriaJSON: function (criteria) {\n            document.querySelector('input[name=\"criteriajsonhelper\"]').value = JSON.stringify(criteria);\n        },\n\n    };\n});"],"names":["define","Log","getClosest","elem","selector","document","parentNode","matches","getPreviousElement","sibling","previousElementSibling","getDistanceFromCriterionHeader","distance","getNextElement","nextElementSibling","getCriteriaJSON","JSON","parse","getElementById","value","getLevelsJSON","criteriaid","setCriteriaJSON","criterioncollection","stringify","getCriterionFromCriteriaCollection","row","filter","criterion","index","id","getAttribute","rowindex","getRandomID","Math","floor","random","getMode","querySelector","getMinMax","score","indexOf","split","getMaxValueInLevelInCriterion","groupid","maxvalues","marks","querySelectorAll","Array","from","forEach","minmax","push","Number","length","max","setHiddenCriteriaJSON","criteria"],"mappings":";;;;;;AAwBAA,4CAAO,CAAC,aAAa,SAAUC,WAGpB,CAEHC,WAAY,SAAUC,KAAMC,eACjBD,MAAQA,OAASE,SAAUF,KAAOA,KAAKG,cACtCH,KAAKI,QAAQH,iBACND,YAGR,MAGXK,mBAAoB,SAAUL,KAAMC,cAG5BK,QAAUN,KAAKO,0BAGdN,cAMEK,SAAS,IAERA,QAAQF,QAAQH,iBACTK,QAEXA,QAAUA,QAAQC,yBAI1BC,+BAAgC,SAAUR,KAAMC,cACxCK,QAAUN,KAAKO,uBACfE,UAAY,KAEXR,cAIEK,SAAS,IACZG,WACIH,QAAQF,QAAQH,iBACTQ,SAEXH,QAAUA,QAAQC,yBAK1BG,eAAgB,SAAUV,KAAMC,cAExBK,QAAUN,KAAKW,sBAEdV,cAKEK,SAAS,IACRA,QAAQF,QAAQH,iBACTK,QAEXA,QAAUA,QAAQK,qBAI1BC,gBAAiB,kBACNC,KAAKC,MAAMZ,SAASa,eAAe,eAAeC,QAG7DC,cAAe,SAAUC,mBACdhB,SAASa,iDAA0CG,0BAAwBF,OAGtFG,gBAAiB,SAAUC,4BAChBlB,SAASa,eAAe,eAAeC,MAAQH,KAAKQ,UAAUD,sBAGzEE,mCAAoC,SAAUC,IAAKH,4BAErBA,oBAAoBI,QAAO,SAAUC,UAAWC,aAChEC,GAAKJ,IAAIK,aAAa,2BAE5BH,UAAUI,SAAWH,MACjBC,IAAMF,UAAUE,UACTF,YAEZF,MAKPO,YAAa,kBACDC,KAAKC,MAAsB,KAAhBD,KAAKE,WAG5BC,QAAS,kBACEhC,SACFiC,cAAc,qBACdP,aAAa,cAGtBQ,UAAW,SAAUC,cACU,GAAvBA,MAAMC,QAAQ,KACPD,MAAME,MAAM,KAEZF,MAAME,MAAM,MAM3BC,8BAA+B,SAAUC,eAC/BC,UAAY,GACZC,MAAQzC,SAAS0C,kCAA2BH,uCAElDI,MAAMC,KAAKH,OAAOI,SAAQV,cAChBW,OAASX,MAAMrB,MAAMuB,MAAM,KACjCG,UAAUO,KAAKC,OAAOF,OAAOA,OAAOG,OAAS,OAE9CT,WAEIX,KAAKqB,OAAOV,YAQvBW,sBAAuB,SAAUC,UAC7BpD,SAASiC,cAAc,oCAAoCnB,MAAQH,KAAKQ,UAAUiC"}